import { db } from './index';

/**
 * ⚠️ HELPER TEMPORAIRE DE DEBUG
 * Supprime toutes les dépenses auto-générées par l'ancien système de recurring
 */
export const cleanupAutoGeneratedExpenses = (): number => {
  try {
    const result = db.runSync(`DELETE FROM expenses WHERE id LIKE 'expense-recurring-%'`);
    return result.changes;
  } catch (error) {
    console.error('Cleanup error:', error);
    return 0;
  }
};

/**
 * Reset complet de toutes les données (budgets + expenses + incomes)
 */
export const resetAllData = (): void => {
  try {
    db.execSync('DELETE FROM expenses');
    db.execSync('DELETE FROM budgets');
    db.execSync('DELETE FROM incomes');
    console.log('✅ All data reset (expenses, budgets, incomes)');
  } catch (error) {
    console.error('Reset error:', error);
  }
};

/**
 * Reset TOTAL - Supprime TOUT (y compris recurring)
 */
export const resetEverything = (): void => {
  try {
    db.execSync('DELETE FROM expenses');
    db.execSync('DELETE FROM budgets');
    db.execSync('DELETE FROM incomes');
    db.execSync('DELETE FROM recurring_expenses');
    db.execSync('DELETE FROM user_preferences');
    console.log('✅ EVERYTHING reset');
  } catch (error) {
    console.error('Reset everything error:', error);
  }
};

/**
 * Nettoie uniquement les revenus doublons
 */
export const cleanupDuplicateIncomes = (): number => {
  try {
    // Garder uniquement le plus ancien income pour chaque combinaison (month, source, amount, isRecurring)
    const result = db.runSync(`
      DELETE FROM incomes 
      WHERE id NOT IN (
        SELECT MIN(id) 
        FROM incomes 
        GROUP BY month, source, amount, is_recurring
      )
    `);
    return result.changes;
  } catch (error) {
    console.error('Cleanup duplicates error:', error);
    return 0;
  }
};

/**
 * Nettoie les revenus récurrents en doublon
 * Garde seulement le plus ancien pour chaque combinaison (source, amount)
 */
export const cleanupDuplicateRecurringIncomes = (): number => {
  try {
    // Supprimer tous les revenus récurrents SAUF le plus ancien pour chaque (source, amount)
    const result = db.runSync(`
      DELETE FROM incomes 
      WHERE is_recurring = 1 
      AND id NOT IN (
        SELECT MIN(id) 
        FROM incomes 
        WHERE is_recurring = 1
        GROUP BY source, amount
      )
    `);
    return result.changes;
  } catch (error) {
    console.error('Cleanup recurring incomes error:', error);
    return 0;
  }
};

/**
 * Statistiques détaillées de la base
 */
export const getDatabaseStats = (): {
  totalExpenses: number;
  autoGeneratedExpenses: number;
  budgets: number;
  recurringExpenses: number;
  totalIncomes: number;
  recurringIncomes: number;
} => {
  const totalExpenses = db.getFirstSync<{ count: number }>('SELECT COUNT(*) as count FROM expenses')?.count || 0;

  const autoGeneratedExpenses = db.getFirstSync<{ count: number }>(`SELECT COUNT(*) as count FROM expenses WHERE id LIKE 'expense-recurring-%'`)?.count || 0;

  const budgets = db.getFirstSync<{ count: number }>('SELECT COUNT(*) as count FROM budgets')?.count || 0;

  const recurringExpenses = db.getFirstSync<{ count: number }>('SELECT COUNT(*) as count FROM recurring_expenses')?.count || 0;

  const totalIncomes = db.getFirstSync<{ count: number }>('SELECT COUNT(*) as count FROM incomes')?.count || 0;

  const recurringIncomes = db.getFirstSync<{ count: number }>('SELECT COUNT(*) as count FROM incomes WHERE is_recurring = 1')?.count || 0;

  return {
    totalExpenses,
    autoGeneratedExpenses,
    budgets,
    recurringExpenses,
    totalIncomes,
    recurringIncomes,
  };
};
